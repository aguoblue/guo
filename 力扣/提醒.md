

# 动态规划

>递推公式简单、多样

dp[j] = Math.max(dp[j], dp[j-nums[i]] + nums[i]);
dp[j] += dp[j - nums[i]];
dp[i][j] = Math.max(dp[i][j], dp[ i-zeroNum ]  [ j-oneNum] +1);
dp[j] = Math.min(dp[j-i*i] + 1, dp[j]);
dp[j] = Math.min(dp[j-coins[i]] + 1, dp[j]);

>01背包问题  
>物体只能用1次
>背包能背最大的物体价值，不是一定要等于背包大小

二维数组   先背包先物体都可以
一维数组   外循环物体内循环背包，且内循环倒序遍历，正序导致1物体多用

> 背包大小要等于物体价值

通过判断 dp[ sum ] == sum

> 完全背包
> 物体可以用无限次

二维数组  先背包先物体都行
一维数组  都行、正序
组合个数  target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历。
最少物体个数   初始化最大值、

> 多重背包
> 物体有限次


> 树型dp





分治算法



线段树