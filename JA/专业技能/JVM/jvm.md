# 简介
## 功能
![[Pasted image 20240417184058.png]]
## 常见jvm
![[Pasted image 20240417184027.png]]
## 组成
![[Pasted image 20240417184437.png]]

## 参考
[大白话带你认识 JVM | JavaGuide](https://javaguide.cn/java/jvm/jvm-intro.html)


# 基础篇
## 字节码文件
![[Pasted image 20240417205200.png]]

查看 ： jclasslib
javap是JDK自带的反编译工具


常量池
	String引用 ，指向Utf8_info
	Utf8_info
	有些字段的名字和字段的值一致，就会重复引用Utf8_info
方法
	查看代码对应的字节码指令
```
int i = 0;
i = i++;
 0 iconst_0
 1 istore_1
 2 iload_1
 3 iinc 1 by 1
 6 istore_1

int i = 0;
i = ++i;
 0 iconst_0
 1 istore_1
 2 iinc 1 by 1
 3 iload_1
 6 istore_1
操作数栈（临时存放）
局部变量表数组 main/Code/LocalVariableTable
```

另一个工具  arthas-boot.jar  阿里arthas
运行时监控查看 
	dump命令导出字节码文件到本地查看
	jad命令反编译出源代码

## 类的生命周期

加载Loading
	根据类的全限定名通过不同渠道以二进制流的方式获取字节码信息，JVM将其保存到方法区中，生成一个InstanceKlass对象，保存类的所有信息，同时还会再堆中生成一份与方法区中数据类似的java.lang.Class对象，两者有关联
连接Linking
	验证 验证是否满足《Java虚拟机规范》
		文件格式、元信息、执行指令的语义、符号引用验证
	准备
		给静态变量赋初始值
		如果是final修饰的基本数据类型的静态变量，准备阶段会直接将代码中的值进行赋值
	解析
		将常量池中的符号引用替换为直接引用
初始化Initialization
	-XX:+TraceClassLoading 虚拟机参数，查看加载类
	执行静态代码块中的代码，并为静态变量赋值
	执行字节码文件中clinit部分的字节码指令，clinit部分就是静态代码块执行和静态变量赋值部分，如果有静态变量的声明却没有赋值语句，不会出现该静态变量的clinit指令
	触发类的初始化
	1 访问一个类的静态变量或者静态方法，注意final修饰的并且等号右边是常量不会触发，如果右边不是常量比如Integer.valueOf(1)，会触发初始化
	2 调用Class.forName
	3 new一个该类的对象时
	4 执行Main方法的当前类
	init指令对应到类的构造方法以及非静态代码块，new后会执行init
	直接访问父类的静态变量，不会触发子类的初始化
	子类的初始化clinit调用之前，会先调用父类的clinit初始化方法
	数组的创建不会导致数组中元素的初始化
	final修饰的变量如果赋值的内容需要执行指令才能得出结果，会执行clinit方法进行初始化
使用Using
卸载Unloading

new xxclass
	加载、连接、初始化  clinit（静态代码块、静态变量赋值顺序执行）
	实例化对象时，init（非静态代码块，构造方法）


## 类加载器的分类
类加载器在 Java 中主要负责将类的字节码从不同的来源加载到 Java 虚拟机（JVM）中。这些来源可以是磁盘上的 `.class` 文件、网络、其他文件系统上的文件、数据库中存储的字节码或者存储在 `.jar`（Java ARchive）文件中的类。
类加载器实际加载的是类的字节码，无论这些字节码是存放在单独的 `.class` 文件中还是打包在 `.jar` 文件里。关键是类加载器读取这些字节码，并将它们作为类定义数据传递给 JVM，这样这些类就可以在程序中被使用。
当类存储在 `.jar` 文件中时，类加载器会在 `.jar` 文件内部查找指定的类文件（字节码），然后加载它。`.jar` 文件是一个压缩格式，可以包含多个类文件以及应用程序可能使用的其他资源文件，如图像、文本文件等。
arthas 进入进程，classloader命令查看
类加载器 
	java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术
	java语言，java代码中实现
	c++语言，java虚拟机底层源码实现
	二进制流 ->  类加载器  ->   本地接口(JNI  Java Native Interface)调用，运行java调用其他语言编写的方法
	虚拟机底层实现，比如Hostpot使用c++，保证java程序运行中基础类被正确加载
	java语言实现的类加载器，默认提供或者自定义，继承自ClassLoader抽象类
JDK8及之前版本
	虚拟机底层实现
		启动类加载器Bootstrap
		默认加载安装目录/jre/lib  比如rt.jar
		程序输出为null，安全性
	![[Pasted image 20240420133759.png]]
	Java
		扩展类加载器Extension    扩展java中比较通用的类
			默认加载/jre/lib/ext
			加参数加载指定目录jar
			ExtClassLoader
		应用程序类加载器Application 加载应用使用的类
			加载当前项目中的类以及第三方jar包中的类
			AppClassLoader
		源码在sun.misc.Launcher中，是一个静态内部类。继承自URLClassLoader
用arthas查看类加载器
	启动类加载器为null
	在idea中vm option  -Xbootclasspath/a:jar包目录，使得启动类加载器加载jar包
	查看加载器加载类的路径及jar包  classloader -l    classloader -c hash



双亲委派机制
	向上查找父类加载器是否加载过
	向下尝试加载
按照双亲委派模型，应用程序类加载器会委托给扩展类加载器，扩展类加载器会委托给启动类加载器。如果一个类已经由启动类加载器加载，那么：

- 当应用程序类加载器或其他任何子类加载器被要求加载这个已经加载过的类时，它们会通过类加载器的层次结构向上委托，最终达到启动类加载器。启动类加载器会检查它是否已经加载了这个类。由于类已经被加载，启动类加载器会直接返回这个类的引用，而不会再次加载它。

因此，**应用程序类加载器不会再次加载启动类加载器已经加载过的类**。双亲委派模型确保了Java类的唯一性，每个类在JVM中只会被加载一次（在一个类加载器实例的上下文中），避免被重复加载，并且是由最顶层能够成功加载该类的类加载器加载的。这个机制也增加了Java应用的安全性，防止了核心Java API被恶意替换或篡改。


打破双亲委派机制
	自定义类加载器
		重写loadClass方法
		默认父类加载器是应用程序类加载器
		![[Pasted image 20240420143557.png]]
	![[Pasted image 20240420145749.png]]
		线程上下文类加载器![[Pasted image 20240420145821.png]]
	Osgi框架的类加载器![[Pasted image 20240420154332.png]]![[Pasted image 20240420154355.png]]
	

JDK9引入module概念
	在jmods文件夹中加载jmod
	扩展类加载器变成了平台类加载器


运行时数据区
	线程不共享
		程序计数器
			记录当前要执行的字节码指令的地址
			加载阶段，会将偏移量转换成内存地址
		java虚拟机栈
			每个方法的调用使用一个栈帧
			栈帧
				局部变量表
					编译阶段确定
					存放运行中所有的局部变量
					编号、生效范围、槽的起始编号
					long、double占两个槽、其他1个、槽的重复使用
					实例方法中序号(编号)为0的位置存放的是this、紧跟接收参数、
				操作数栈
					存放临时数据
					编译时期确定了栈的最大深度，从而在执行时正确分配内存大小
				帧数据
					包括动态链接、方法出口、异常表的引用
					当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用转换到对应的运行时常量池中的内存地址，动态链接就保存了这个映射关系
					异常表存放异常信息、异常捕获的生效范围以及异常发生后跳转到的字节码指令位置
			默认大小 1024KB    =   1MB![[Pasted image 20240420201126.png]]![[Pasted image 20240420201244.png]]
		本地方法栈
			存储的是native本地方法的栈帧
			在Hostpot虚拟机中，java虚拟机栈和本地方法栈实现上使用了同一个栈空间
	共享
		方法区
			存放基础信息，类的元信息、运行时常量池、字符串常量池（先是在永久代，后面移至堆内存）
			JDK7之前的版本将方法区存放在堆区域中的永久代空间
			JDK8及之后将方法区存放在元空间，位于操作系统维护的直接内存中，不设上限，可以设置其最大值![[Pasted image 20240420204243.png]]
		堆
			used 已经使用的
			total 已经分配的可用堆内存，total即将不足时，会继续分配给堆，直到接近max，不会到max就退出了，和垃圾回收器有关，默认系统内存1/64
			max  可以分配的最大堆内存 默认系统内存1/4![[Pasted image 20240420203334.png]]
			arthas可查看

字符串常量池案例
```java
String s1 = "Hello";
String s2 = "Hello";
String s4 = "HelloHello";
String s3 = s1 + s2;

```
在Java中，当你使用加号（`+`）操作符连接字符串时，实际上涉及到了`StringBuilder`（在某些旧版本的JDK中是`StringBuffer`）的使用。编译器会自动将字符串连接的代码转换为使用`StringBuilder`的代码，以提高性能。这种转换是在编译时进行的，因为使用`StringBuilder`可以避免多次创建和销毁中间字符串对象，从而提高效率。
![[Pasted image 20240420205458.png]]
```java
StringBuilder sb = new StringBuilder();
sb.append(s1);
sb.append(s2);
String s3 = sb.toString();
```
当调用`toString`方法时，`StringBuilder`会根据累积的字符内容创建一个新的`String`对象并返回。s1和s2都指向字符串常量池中的同一个，而s3指向另一个对象，不是s4，因为`toString`底层会new



`String.intern()`是Java中`String`类的一个方法，它用于返回字符串对象的规范表示。更具体地说，对于任意两个字符串`s`和`t`，`s.intern() == t.intern()`在且仅当`s.equals(t)`为`true`时才为`true`。
当调用`intern()`方法时，如果字符串常量池中已经包含一个等于此`String`对象的字符串，则返回代表池中这个字符串的`String`对象的引用；否则，将此`String`对象添加到常量池中，并返回此`String`对象的引用。
JVM启动时会把java加入到常量池中
JDK7及之后版本`intern()`方法会把第一次遇到的字符串的引用放入字符串常量池中

静态变量
	在JDK7前，在方法区中，也就是永久代
	JDK7及之后，存放在堆中的Class对象中![[Pasted image 20240420205843.png]]

直接内存   NIO机制
	读写文件减少数据复制的开销
	可以创建直接内存上的数据，ByteBuffer，可设置申请的大小![[Pasted image 20240420210615.png]]
	![[Pasted image 20240420210757.png]]
	

## 垃圾回收机制 GC
主要负责堆上的内存进行回收
参数 -verbose:gc 查看垃圾回收的信息

方法区的回收
	类的卸载    同时满足三个条件
		此类所有实例对象被回收、堆中不存在任何该类的实例对象以及子类
		加载该类的类加载器已经被回收
		该类对应的java.lang.Class对象没有在任何地方被引用
	手动触发垃圾回收  调用System.gc()方法
		并不一定会立即回收垃圾，仅仅是向虚拟机发送一个垃圾回收的请求

堆回收
	引用计数法   未被使用
		为每个对象维护一个引用计数器，对象被引用加1，取消引用减1
		缺点
			每次引用和取消引用都要维护，对系统性能有一定的影响
			存在循环引用问题
	可达性分析法  
		将对象分为两类：垃圾回收的根对象(GC Root)和普通对象，对象之间存在引用关系
		如果从某个对象到GC Root对象是可达的，就不可回收
		GC Root
			线程Thread对象
			系统类加载器加载的java.lang.Class对象，引用类中的静态变量
			监视器对象，用来保存同步锁synchronized关键字持有的对象
			本地方法调用时使用的全局对象
		查看GC Root
			arthas导出堆内存快照
			MAT工具打开快照并查看
	软引用
		如果一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收，常用于缓存中   
		SoftReference类实现软引用，通过构造器传入引用队列，在软引用中包含的对象被回收时，该软引用对象会被放入引用队列
		实现缓存
	弱引用
	虚引用
	终结器引用
	垃圾回收算法
		找到内存中存活的对象，释放不再存活对象的内存
		单独GC线程，有部分阶段需要停止所有的用户线程  STW
		评判标准
			吞吐量
			最大暂停时间
			堆使用效率
				标记清除算法，使用完整堆内存
				复制算法将堆内存一分为二，每次只能使用一半
			一般堆内存最大，最大暂停时间越长。
			减少最大暂停时间，类似进行多次小型的回收，每次回收都有固定开销，导致总时间更长，就会降低吞吐量
		1标记清除算法
			标记阶段，利用可达性分析，标记存活对象
			清除阶段
			优点
				实现简单，第一阶段给每个对象维护标志位，第二阶段删除即可
			缺点
				1碎片化问题 内存碎片，很多细小的可用内存单元，如果需要分配较大的空间可能无法分配
				2分配速度慢 内存碎片维护，空闲链表，可能需要遍历到链表最后才能获得合适的内存空间
		2复制算法
			From空间  To空间
			遍历一次存活对象，复制到To空间，清除From空间，把From改名成To，To改名成From
			优缺点
				吞吐量高，比标记-整理少一次遍历，但性能不如标记-清除，标记清除不需要对象移动
				不会发生碎片化
				内存使用效率低，只能使用一半内存来创建对象使用
		3标记整理算法
			标记阶段，可达性分析标记所有存活对象
			整理阶段，将存活对象移动到堆的一端，清理掉另一端
			优缺点
				内存使用效率高，整个内存都可以使用
				不会发生碎片化
				整理阶段的效率不高
		4分代GC
			年轻代
				存放存活时间比较短的对象
				Eden区 伊甸园
				S0 幸存区
				S1
				Eden区满，触发年轻代GC   Minor GC
				Minor GC会把eden和S0 from中需要回收的对象回收，把没有回收的对象放入S1 To区，然后S0变成To区，S1变成From区，当Eden区满时再往里放入对象，依旧会触发Minor GC，此时会回收eden和S1 from中的对象，并把剩余的对象放入S0 To，重复交换。
				每次Minor GC都会为对象记录他的年龄，初始为0，每次GC完加1
				年龄到达阈值 最大15，对象会晋升至老年代
				当老年代中空间不足，无法放入新的对象，会先尝试minor gc，如果还是不够，就触发Full GC，对整个堆进行垃圾回收
				先尝试minor gc，是有这种情况，年轻代满了（Eden满），但对象年龄还没到阈值，年龄最大的对象需要被转移到老年代区中
			老年代
				存放存活时间比较长的对象
	垃圾回收器
		种类
			年轻代
				Serial、ParNew、Parallel Scanvenge
			老年代
				CMS、Serial Old、Parallel Old
			Serial--Serial Old、ParNew--CMS、Parallel Scanvenge--Parallel Old
			JDK14废弃了 CMS
			G1  JKD9后常用
			Serial
				单线程串行、回收年轻代、复制算法
				处理时用户线程都要等待
				优点  单CPU处理器下吞吐量出色
				缺点  多CPU下吞吐量不如其他，堆偏大会让用户线程等待过长时间
				适合  Java编写的客户端程序或者硬件配置有限的场景
			Serial Old 
				单线程串行、回收老年代、标记-整理算法
				其他和Serial类似
			ParNew
				年轻代、多线程回收
				处理时用户线程都要等待
				优点  多CPU处理器下停顿时间较短
				缺点  吞吐量和停顿时间不如G1，JDK9后不建议使用
				使用JDK9之前版本，与CMS搭配使用
			CMS
				初始标记、并发标记、重新标记、并发处理
				老年代、标记清除
				优点  停顿时间短、用户体验好
				缺点  内存碎片、退化、浮动垃圾
				适用  大型的互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等
				初始标记  极短时间内标记GC Roots直接关联到的对象，用户线程暂停
				并发标记  标记所有对象，用户线程不需要暂停，主要看占用cpu率
				重新标记  并发标记阶段可能有变化，存在错标、漏标等情况，多线程执行重新标记，用户线程暂停
				并发清理  清理死亡对象，用户线程不需要暂停
				CMS会在Full GC时进行碎片的整理，用户线程暂停
				无法处理并发过程中产生的浮动垃圾，做不到完全的垃圾回收
				老年代内存不足无法分配，CMS退化成Serial Old
			Parallel Scanvenge
				JDK8默认 年轻代、复制、多线程并行回收、关注吞吐量可手动可控
				具备自动调整堆内存的大小
				用户线程暂停
				缺点  不能保证单次的停顿时间
				适用  后台任务，无需与用户交互，容易产生大量对象
			Parallel Old
				老年代、标记-整理算法
			G1 Garbage First
				JDK9之后默认
				支持巨大的堆空间回收，有较高的吞吐量
				支持多CPU并行垃圾回收
				运行用户设置最大暂停时间
				Region区 不要求连续 堆空间大小/2048
				年轻代回收 Young GC
					回收Eden、Survivor中不用的对象 导致STW、可设置默认200
					新建的对象放到Eden，当G1判断年轻代不足时(Max默认60%)，无法分配对象时需要回收，触发Young GC
					标记出Eden、Survivor中存活的对象
					根据配置的最大暂停时间选择某些区域将存活对象复制到一个新的Survivor区中，年龄加1，再清空
					会记录每次垃圾回收时每个区的平均耗时，作为参考
					年龄达到最大，放入Old区
					部分对象大小超过Region的一半，直接放入老年代Humongous区，对象过大会横跨多个Region区
					总堆占有率达到阈值，触发混合回收
				混合回收   Mixed GC
					回收所有年轻代和部分老年代以及大对象区，复制算法
					初始标记
						标记Gc Roots直接引用的对象为存活 多线程 用户线程暂停
					并发标记
						将第一步中标记的对象引用的对象标为存活，用户线程不暂停
					最终标记
						标记一些引用改变漏标的对象，不管新创建、不再关联的对象，用户线程暂停
					并发清理
						存活对象移到别的Region，复制算法，用户线程不暂停，同时内部有优化，也不是将所有Region进行回收，选择一些存活度低的区域进行回收
				Full GCL
					找不到空Region存放转移的对象
					单线程执行标记-整理算法，用户线程暂停
		使用
			